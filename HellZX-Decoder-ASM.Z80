;    __  __     _________  _  __               _ __
;   / / / /__  / / /__  / | |/ /____________  (_) /_  ___  _____
;  / /_/ / _ \/ / /  / /  |   / ___/ ___/ _ \/ / __ \/ _ \/ ___/
; / __  /  __/ / /  / /__/   / /__/ /  /  __/ / /_/ /  __/ /
;/_/ /_/\___/_/_/  /____/_/|_\___/_/   \___/_/_.___/\___/_
;
; Hellscreiber plotter for ZX Spectrum
; Daniel Josï¿½ Viana, 2014
; danjovic@gmail.com
;
; This code is GPL
;
; Alfa release 13 apr 2014
;


;$EFFE keys 0, 9, 8, 7, 6
;$F7FE keys 5, 4, 3, 2, 1
;


; *****************************************************************
;      ____       _____       _ __  _
;     / __ \___  / __(_)___  (_) /_(_)___  ____  _____
;    / / / / _ \/ /_/ / __ \/ / __/ / __ \/ __ \/ ___/
;   / /_/ /  __/ __/ / / / / / /_/ / /_/ / / / (__  )
;  /_____/\___/_/ /_/_/ /_/_/\__/_/\____/_/ /_/____/
;


CHOPEN:      EQU  1601h
CLS:         EQU 0d6bh
ROM_PLOT:    EQU 022E5h
IO_KEMPSTON: EQU 31
BT_MASK:     EQU %10000




Delay_105: EQU 0b0h;023Eh
Delay_122: EQU 094h;01E3h
Delay_245: EQU 03fh;00D4h








; *****************************************************************
;     _____ __             __
;    / ___// /_____ ______/ /___  ______
;    \__ \/ __/ __ `/ ___/ __/ / / / __ \
;   ___/ / /_/ /_/ / /  / /_/ /_/ / /_/ /
;  /____/\__/\__,_/_/   \__/\__,_/ .___/
;                               /_/
;
org 08000h


Initialize:
      ld A,2      ; a=screen
      call CHOPEN ; call channel open
      call CLS    ; call cls


      ; Banner
      ld hl,msgbanner1
      call PRINTAT
      ld hl,msgbanner2
      call PRINTAT




      ; show title
      ld HL,msgabout
      call PRINTAT


      ; show credits
      ld HL, msgauthor
      call PRINTAT


      ; set initial speed
      ld a,1   ; 122.5 baud
      ld (Speed_index),A
      call Set_Speed
      call Show_Speed


      ; debug only - show elapsed time in hexa
      ; ld B,22
      ; ld c,0
      ; call LOCATE
      ; ld c,(IY+$3E)
      ; ld b,(IY+$3f)
      ; call PRINTHX4






      ld A,2      ; a=screen
      call CHOPEN ; call channel open




; *****************************************************************
;      __  ___      _          __
;     /  |/  /___ _(_)___     / /   ____  ____  ____
;    / /|_/ / __ `/ / __ \   / /   / __ \/ __ \/ __ \
;   / /  / / /_/ / / / / /  / /___/ /_/ / /_/ / /_/ /
;  /_/  /_/\__,_/_/_/ /_/  /_____/\____/\____/ .___/
;                                           /_/


Mainloop:
      ld D,0     ; D=Strip(*28)
Do_Strip:
      ld H,0     ; H=Row
Do_Row:
      ld l,13    ;ld L,0     ; L=Line
Do_Line:


      ; Read Keyboard
      ld A,0F7h     ; Select column  5, 4, 3, 2, 1
      in A,(0FEh)   ; read Row
      rla
      or  %11011111
      ld E,A        ; Key 5 in bit 5
      ld A,0EFh     ; Select column  6, 7, 8, 9, 0
      in A,(0FEh)   ; read Row
      or  %11100000 ; mask bits of keys 6 7 8 9 0
      and E
      ld E,A
      cpl   ; store input in E = - - 5 6  7 8 9 0
              
      ld (InKeys),A




      ; Calculate coordinates
      ld A,D
      add A,L
      ld B,A     ; B=Strip*28+Line
      ld A,175
      sub B
      ld B,A     ; B=175-(Strip*28+Line)
      ld C,H     ; H=Row


       ; Sample Ear Input
       call SAMPLE_EAR  ; on exit A=1 (plot) or 0 (unplot)




      ; Plot or Unplot pixel
      and E      ; mix ear input sampling result with keyboard in E
      ld E,A




;      in A,(31) ; read Kempston joystick
;      or E      ; mix input with keyboard and ear samples




      ; Plor or Unplot
      and 1     ; bit 1 is LOW for either "0" on keyboard or
                ;                         signal present at "ear" connector
      jr z,Pixel_reset
;      jr z,Pixel_set
;
Pixel_set:
      set 2,(IY+057h) ; Set Inverse on P_FLAG
      jr Do_Plot
Pixel_reset:
      res 2,(IY+057h) ; Reset Inverse on P_FLAG
Do_Plot:
      push HL         ; Save Row and Line
      push DE         ; Save Strip(*28) and Last Key
      push BC         ; Save Coordinates


      call ROM_PLOT   ; Plot at B,C coordinates
      pop BC          ; Restore Coordinates
      ld A,B
      sub 14 ;14
      ld B,A
      call ROM_PLOT ; plot at B-14,C coordinates


      ; CHECK Keys Pressed
      call Check_Keys


      ;  Delay
      ld DE,(Delay_Reload)
Dl_Loop:
      dec de
      ld a,e
      or d
      jr nz,Dl_Loop


      pop DE      ; restore Strip value in D
      pop HL      ; restore Row and Line values in H and L




Next_Line:
      dec L       ;inc L
      ld A,L
      cp 0ffh     ;cp 14
      jr nz,Do_Line
Next_Row:
      inc H
      jr nz,Do_Row
Next_Strip:
      ld A,28
      add A,D
      ld D,A         ;D=D+28
      cp 28*6
      jr c,Do_Strip
Repeat:
      ; for debug only
      ; ld c,(IY+$3E)
      ; ld b,(IY+$3f)
      ; call PRINTHX4


      jr Mainloop




; *****************************************************************
;     _____       __                     __  _
;    / ___/__  __/ /_  _________  __  __/ /_(_)___  ___  _____
;    \__ \/ / / / __ \/ ___/ __ \/ / / / __/ / __ \/ _ \/ ___/
;   ___/ / /_/ / /_/ / /  / /_/ / /_/ / /_/ / / / /  __(__  )
;  /____/\__,_/_.___/_/   \____/\__,_/\__/_/_/ /_/\___/____/
;




;
; Check Keyboard press and execute commands
;
Check_Keys:
      ld A,(InKeys)
      and %00111110 ; discard key 0 and other unused bits
      ld E,A
      cp %00000000
      jr z,Test_Release
      ld a,(Last_Key)
      cp E
      jr NZ,NewKey
Being_Pressed:
      ld A,(Key_Counter)
      inc A
      jr nz,Bng_Prs1      ; Limita Key Counter a 255
      dec a
Bng_Prs1:
      ld (Key_Counter),A
      ;jr End_Check_Keys
      ret


Test_Release:
      ld a,(Key_Counter)
      cp 8 ; Treshold
      jr c,Clear_Key_Counter


      ; Execute command
      ld a,(Last_Key)  ; Switch (Last_Key)
      cp %00100000 ; key 5     case Key 5
      jr z,More_Delay
      cp %00010000 ; key 6
      jr z,Less_Offset
      cp %00001000 ; key 7
      jr z,More_Offset
      cp %00000100 ; key 8
      jr z,Less_Delay
      cp %00000010 ; key 9
      jr z,Toggle_Speed
Tst_Rls1:
      jr Clear_Key_Counter


NewKey:
      ld A,E
      ld (Last_Key),A


Clear_Key_Counter:                ; main exit point of Check Keys subroutine
      xor A
      ld (Key_Counter),A
End_Check_Keys:
      ret


Less_Delay:
      ld A,(Fine_Tune)
      and A  ; minimum delay is zero (-16)
      ret z
      dec A
      ld DE,(Delay_Reload)
      dec DE
      jr Update_Display_Speed


More_Delay:
      ld a,(Fine_Tune)
      cp 31           ; maximum delay is 31 (+15)
      ret z
      inc a
      ld DE,(Delay_Reload)
      inc DE


Update_Display_Speed:
      ld (Fine_Tune),A
      ld (Delay_Reload),DE


      SRL D ; divide by four to put on Treshold
      RR E
      SRL D
      RR E
      SRL D
      RR E
      SRL D
      RR E
      ld (Treshold),DE


      call Show_Speed
      jr Clear_Key_Counter


Less_Offset:
      call Show_Offset
      ret


More_Offset:
      call Show_Offset
      ret


Toggle_Speed:
      ; Point to next speed index
      ld A,(Speed_index)
      inc A
      cp 3
      jr nz,Tog_Sp0
      xor A
Tog_Sp0:
      ld (Speed_index),A
      call Set_Speed
      call Show_Speed
      jr Clear_Key_Counter








; -------------------------------------------------------
;
; Show speed bar proportional to Fine_Tune variable
;
Show_Speed:
      ld B,3
      ld c,26*8
      ld E,32
Do_Bar:
      ld a,(Fine_Tune)
      cp e
      jr c,set_px
res_px:
      set 2,(IY+057h) ; Set Inverse on P_FLAG
      jr SSPlot
set_px:
      res 2,(IY+057h) ; Reset Inverse on P_FLAG
SSPlot:
      push de


      push BC
      call ROM_PLOT
      pop bc


       ; Plot at B+1,C coordinates
      push bc
      ;inc b
      inc B
      call ROM_PLOT
      pop bc


      inc c
      pop de
      dec e
      ld a,e
      and a


      jr nz,Do_Bar
ret


; -------------------------------------------------------
;
; Show Offset position
;
Show_Offset:
      ret     ; to be implemented




; -------------------------------------------------------
;
; Set speed to predefined index and print it
;
Set_Speed:
      ; Select constants and messages
      cp 2   ; is 245 baud?
      ld HL,msg245cps
      ld DE,Delay_245
      jr z,Upd_Spd_Screen


      cp 1 ; is 122.5 baud?
      ld HL,msg122cps
      ld DE,Delay_122
      jr z,Upd_Spd_Screen


      ; then is 105 baud
      ld HL,msg105cps
      ld DE,Delay_105


Upd_Spd_Screen:
      ld a,16           ; fine tuning at center position
      ld (Fine_Tune),a
      ld (Delay_Reload),DE
      call PRINTAT
;      push HL
;      ld B,22
;      ld c,24
;      call LOCATE
;      pop HL
;      call PRINTS
ret






; -------------------------------------------------------
; PRINT routine
;
; from ADVANCED SPECTRUM MACHINE LANGUAGE
; by David Webb
; Entry: A=Char Code
; Preserved: C
; Exit: B=0, DE=Attribute Address


;BASE: dw 3C00h
;DFCC: dw 4000h
;ATT:  db 38h
;MASK: db 0


; Construct Character Data Address
PRINT1:  ld L,A
         ld H,0
         add HL,HL
         add HL,HL
         add HL,HL
         ld DE,(BASE)
         add HL,DE
; Take Display File Address
         ld DE,(DFCC)
         ld B,8
; Print Character Row By Row
NXTROW:  ld A,(HL)
         ld (DE),A
         inc HL
         inc D
         djnz NXTROW
; Construct Attribute Address
         ld A,D
         rrca
         rrca
         rrca
         dec A
         and 3
         or 58h
         ld D,A
         ld HL,(ATT) ; H=Mask, L=Attribute
         ld A,(DE)
; Construct New One
         xor L
         and H
         xor L
; Replace Attribute
         ld (DE),A
; Finally Set DFCC to Next Print Position
         ld HL,DFCC
         inc (HL)
         ret nz
         inc HL
         ld A,(HL)
         add A,8
         ld (HL),A
         ret




; -------------------------------------------------------
;
; LOCATE routine
;
; from ADVANCED SPECTRUM MACHINE LANGUAGE
; by David Webb
; Entry:B=Line, C=Column
; Preserved: BC
; Exit: HL=D.F. Address, DE=ATTR.
; DF-CC is Altered
;
;DFCC: equ 5c84h
;
LOCATE:  ld A,B
         and 18h
         ld H,A
         set 6,H
         rrca
         rrca
         rrca
         or 58h
         ld D,A
         ld A,B
         and 7
         rrca
         rrca
         rrca
         add A,C
         ld L,A
         ld E,A
         ld A,(DE)
         ld (DFCC),HL
         ret


; -------------------------------------------------------
;
; Print a message at given coordinates
;
; Entry: HL=Message, preceeded by Line,Column and terminated by 0
; Preserved:
; Exit:
;
PRINTAT:
      ld B,(HL)
      inc HL
      ld C,(HL)
      inc HL
      push HL
      call LOCATE
      pop HL
      call PRINTS
      ret








; -------------------------------------------------------
;
; PRINTS Print a message terminated by 0
;
; Entry: HL=Message
; Preserved:
; Exit:
;
PRINTS:  push HL
         ld A,(HL)
         or A
         jr z,PRTS0 ; termina
         call PRINT1
         pop HL
         inc HL
         jr PRINTS
PRTS0:   ;termina
         pop HL
         ret




; -------------------------------------------------------
;
; Print Hexadecimal number in register C
;
PRINTHX2:
         ld A,C
         rra
         rra
         rra
         rra
         call Print_Nibble
         ld A,C
Print_Nibble:
         and 0fh
         cp 9+1
         jr c,Print0_9
         add a,'A'-'0'-10
Print0_9:
         add A,'0'
         call PRINT1
         ret
; Print Hexadecimal number in registers BC
PRINTHX4:
         push BC
         ld C,B
         call PRINTHX2
         pop BC
         call PRINTHX2
         ret


; -------------------------------------------------------
;
; Sample EAR signal while performs bit delay
;
; Entry: "Delay_Reload", "Treshold" variables
; Preserved: HL,DE
; Exit: A=0 (plot) or 1 (unplot)
;
;boolean Sample_Ear() {
;     ones_count=0
;     delay_cycles = Delay_Reload
;
;//   Sample input
;     do {
;         if (ear_input==0)  ones_count++   ;  ones_count never be > 16 bit. no need to check overflow.
;     } while (--delay_cycles>0)
;
;//   Compare amount of times signal was active during sample time with treshold
;
;     if (ones_count > treshold)
;         Plot_pixel =1
;     else
;         Plot_pixel =0
;
;     return Plot_Pixel


SAMPLE_EAR:


      ; Save Registers
      push HL
      push DE




      ld HL,0                ; ones_count=0
      ld DE,(Delay_Reload)   ; delay_cycles = Delay_Reload


      ; _do  {
SMP_EAR0:
      in A,(0FEh)        ; if (ear_input!=0)  ones_count++
      bit 6,A            ; ear_input is bit 6
      jr z,SMP_EAR1
      inc HL
SMP_EAR1: ; end if


      dec de
      ld a,e
      or d
      jr nz,SMP_EAR0
      ; } while (--delay_cycles>0)




;  ; Check to wether plot or not
;
      xor A             ; clear A and carry flag
      ld DE,(Treshold)
      sbc HL,DE         ; CY=(ones_count-treshold)


      RLA               ; transfers CY for A




      ; restore registers
      pop DE
      pop HL


      ret ; on exit A=1 (plot) or 0 (unplot)










; *****************************************************************
;     ______                 __              __
;    / ____/___  ____  _____/ /_____ _____  / /______
;   / /   / __ \/ __ \/ ___/ __/ __ `/ __ \/ __/ ___/
;  / /___/ /_/ / / / (__  ) /_/ /_/ / / / / /_(__  )
;  \____/\____/_/ /_/____/\__/\__,_/_/ /_/\__/____/
;


CONST:                     ;12345678901234567890123456789012
        msgabout:  db 21,0,"HellZXchreiber          -",07ch,"    ",07ch,"+",0
        msgauthor: db 23,0,"by Danjovic - 2014",0
        msg105cps: db 22,24," 105.cps",0
        msg122cps: db 22,24,"122.5cps",0
        msg245cps: db 22,24," 245.cps",0
                               ;12345678901234567890123456789012
        msgbanner1:   db  9,10,          "Hellschreiber",0
        msgbanner2:   db 11,9 ,        "for ZX Spectrum",0


; *****************************************************************
;   _    __           _       __    __
;  | |  / /___ ______(_)___ _/ /_  / /__  _____
;  | | / / __ `/ ___/ / __ `/ __ \/ / _ \/ ___/
;  | |/ / /_/ / /  / / /_/ / /_/ / /  __(__  )
;  |___/\__,_/_/  /_/\__,_/_.___/_/\___/____/
;


VARS:
      Speed_index: db 0
      Fine_Tune: db 16
      Delay_Reload:
      Delay: dw Delay_122


      Treshold: dw Delay_122/4  ; treshold is the Delay_Reloaded divided by 4
      InKeys: db 0
      Key_Counter: db 0
      Last_Key: db %00000000


      BASE: dw 3C00h
      DFCC: dw 4000h
      ATT:  db 38h
      MASK: db 0




end 08000h
